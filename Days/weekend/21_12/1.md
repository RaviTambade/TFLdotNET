# *From Raw Coding to Applications*

### ğŸŒ± **The Early Days â€“ Before Design Patterns (1980s)**

Letâ€™s go back in time.

Imagine you are a **core developer in the 1980s**.

* Languages used:

  * C
  * C++
  * COBOL
  * FORTRAN

At that time:

* Applications were written in **raw coding style**
* No frameworks
* No architectural guidance
* Everything lived together in one place

Applications **worked**, butâ€¦

âŒ They were hard to extend
âŒ Changes caused chaos
âŒ Maintenance was painful
âŒ Scaling was almost impossible

As applications **grew bigger**, developers realized:

> â€œWe need a better way to structure our code.â€

### ğŸ§  **Birth of Design Patterns**

Developers started observing:

* Repeated solutions
* Common coding structures
* Similar ways of solving similar problems

They **named** these recurring solutions.

ğŸ‘‰ Thus, **Design Patterns** were born.

### ğŸ§© **The 23 Classic Design Patterns**

These patterns were classified into **three categories**:

#### 1ï¸âƒ£ Creational Patterns

Concerned with **object creation**

Examples:

* Singleton
* Factory
* Builder
* Prototype

#### 2ï¸âƒ£ Structural Patterns

Concerned with **object composition**

Examples:

* Adapter
* Decorator
* Facade
* Composite

#### 3ï¸âƒ£ Behavioral Patterns

Concerned with **object interaction & behavior**

Examples:

* Strategy
* Observer
* State
* Command

### ğŸš€ **Why Design Patterns Matter**

Applications built with design patterns are:

âœ… Cleaner
âœ… More maintainable
âœ… Loosely coupled
âœ… Easier to extend
âœ… Industry-ready

Design patterns help developers **think in architecture**, not just code.

## ğŸ§  Fast Forward to Today â€“ AI Era

Today:

* Humans identify **business requirements**
* Translate customer expectations into **technical solutions**
* Business problems are **complex**
* Applications change rapidly

So we no longer:

* Write everything in `public static void main()`
* Build everything from scratch every time

Instead:

* We follow **standard practices**
* Use **patterns**
* Apply **layered architecture**
* Focus on **separation of concerns**

## ğŸ¯ Real Example: Shopping Cart in ASP.NET Core MVC

Now letâ€™s connect theory to **real application development**.

### ğŸ“Œ Requirement

You are building an **ASP.NET Core MVC application** with:

* `ProductsController`
* `ShoppingCartController`

ShoppingCartController should have:

* `AddToCart`
* `RemoveFromCart`
* `Index`

Each **user must have a separate shopping cart**.

### ğŸ§  Design Decision

Which design pattern fits here?

ğŸ‘‰ **Singleton Pattern**

But waitâ€¦
Singleton with **session-awareness**.

### ğŸ§© Why Singleton for CartService?

* One **CartService** instance for the application
* Internally manages **separate carts per user**
* Uses **Session** to differentiate users

So logically:

* Singleton service
* Multiple cart instances (per user)

This is **controlled object creation** â†’ **Creational Pattern**

### ğŸ— Architecture Overview (Separation of Concerns)

#### ğŸ“ Models

* `Product`
* `CartItem`
* `ShoppingCart`

#### ğŸ“ Controllers

* `ProductsController`
* `ShoppingCartController`
* (Later: OrderController)

#### ğŸ“ Services

* `ICartService`
* `CartService` (Singleton)

### ğŸ” Flow of Shopping Cart Service

The CartService:

* Reads cart from **Session**
* Adds product
* Removes product
* Updates session

ğŸ‘‰ Controller never knows **how** cart is stored
ğŸ‘‰ Controller only calls service methods

That is **loose coupling**.

### ğŸ”— Dependency Injection (IOC)

ASP.NET Core gives us:

âœ… Built-in IOC Container
âœ… Constructor Injection
âœ… Lifetime management

We register:

* `CartService` as **Singleton**
* Controllers automatically receive it

This makes the application:

* Testable
* Maintainable
* Scalable

### ğŸ§  Patterns at Play Here

| Concern          | Pattern                |
| ---------------- | ---------------------- |
| Cart Service     | Singleton              |
| Business rules   | Strategy-like thinking |
| Controller logic | MVC                    |
| Communication    | Dependency Injection   |
| State            | Session-based          |


### ğŸ Final Mentor Advice

> Design patterns are not about memorizing 23 names.
> They are about **thinking patterns**.

If students:

* Build real apps
* Face real problems
* Apply patterns naturally

ğŸ‘‰ They **become architects**, not just coders.





# *From Assembled Computers to Dependency Injection & Interfaces*

### ğŸ–¥ï¸ **College Days â€“ A Simple but Powerful Lesson**

Heyâ€¦ I still remember my college days.

After passing out, I joined **City Infotech**.
At that time, we had a requirement:

> â€œWe need a computer for the lab.â€

Now we had **two options**:

1ï¸âƒ£ Buy a **branded desktop**
2ï¸âƒ£ Buy an **assembled computer**


### ğŸ’° The Cost Comparison (Year 2000)

* **Assembled computer** â†’ â‚¹25,000
* **Compaq Presario (Branded)** â†’ â‚¹40,000

For us, â‚¹15,000 was a **big difference** at that time.

So we asked a simple engineering question:

> â€œCan we build it ourselves?â€


### ğŸ”§ The Assembled Computer Experience

So me and my friend went to the market.

We purchased:

* Motherboard
* Cabinet
* Processor (multiple variants existed even then)
* Monitor
* Keyboard
* Mouse
* Chips, transistors, diodes, LEDs

Everything was **separate**, **replaceable**, **standardized**.

If something failed:

* Replace only that part
* No need to discard the entire system
* Maintenance cost was **low**

That day, unknowingly, we learned our **first software architecture lesson**.

## ğŸ§  The Hidden Principle We Learned

> **Standardized components + well-defined interfaces = flexible system**

Each hardware part:

* Followed a **standard interface**
* Could be replaced by another vendor
* Still worked with the same motherboard

ğŸ’¡ That is exactly how **interfaces** work in software.

## ğŸ”Œ Mapping Hardware to Software

| Hardware World | Software World         |
| -------------- | ---------------------- |
| Motherboard    | IOC Container          |
| Processor      | Service Implementation |
| Socket         | Interface              |
| Vendor change  | Implementation swap    |
| Assembled PC   | Loosely Coupled App    |


## ğŸ§© Interface â€“ The Contract

An **interface** is like a **rental agreement**:

* Owner signs it
* Tenant signs it
* Both agree on rules
* Implementation may differ, contract remains same

In software:

* Interface defines **what**
* Class defines **how**

## ğŸ—ï¸ ASP.NET Core & IOC Container

In ASP.NET Core:

* Services are registered in `Program.cs`
* Using:

  ```csharp
  builder.Services.AddSingleton<>();
  builder.Services.AddScoped<>();
  builder.Services.AddTransient<>();
  ```

This is like:

* Plugging hardware components into motherboard slots
* IOC container manages creation & lifetime

## ğŸ›’ Shopping Cart Example (Real Application Thinking)

You are building:

* `ProductsController`
* `ShoppingCartController`

Now question:

> Should controller directly create CartService?

âŒ No.

Why?

* Tight coupling
* Hard to test
* Hard to change


## âœ… Correct Approach

1ï¸âƒ£ Define an **interface**

```csharp
IShoppingCartService
```

2ï¸âƒ£ Implement it

```csharp
ShoppingCartService
```

3ï¸âƒ£ Register it in IOC container
4ï¸âƒ£ Inject it via **constructor**

## ğŸ§  Why Constructor Injection?

Student question:

> â€œWhy parameterized constructor?â€

Answer (Mentor-style):

In ASP.NET Core:

* Controller objects are created by framework
* Before controller is created, **dependencies must be ready**
* Constructor ensures:

  * Dependency exists
  * Dependency is initialized
  * Dependency is available for all action methods

This is **controlled object creation**.

## ğŸ¯ Delegation Principle

Controllerâ€™s job:

* Accept request
* Delegate work

Serviceâ€™s job:

* Business logic

So:

* `AddToCart()` â†’ delegates to CartService
* `RemoveFromCart()` â†’ delegates to CartService
* `Index()` â†’ delegates to CartService

This is:

* **Single Responsibility Principle**
* **High Cohesion**
* **Loose Coupling**

## ğŸ§ª Unit Testing Advantage

Now ask students:

* Can we unit test controller? âœ…
* Can we unit test service? âœ…
* Can we unit test repository? âœ…

Why?
Because:

* Everything is interface-based
* Dependencies are injectable
* No hard-coded objects

## ğŸ”’ Const & Readonly â€“ Safety in Design

Just like hardware specs donâ€™t change at runtime:

* `const` â†’ compile-time fixed
* `readonly` â†’ assigned once at construction

This prevents:

* Accidental value changes
* Runtime malfunction

## ğŸšª Program.cs â€“ The Entry Gate

`Program.cs` is:

* Entry point
* Startup logic
* Dependency Injection configuration
* Middleware pipeline setup

If Program.cs is wrong:

* Application wonâ€™t behave correctly

## ğŸ§  Final Mentor Takeaway

> Assembled computers taught us flexibility
> Interfaces taught us contracts
> IOC taught us control
> Dependency Injection taught us design thinking

And thatâ€™s how:

* Hardware wisdom
* Became
* **Modern software architecture**


# *Program.cs â€“ The Motherboard of an ASP.NET Core Application*


### ğŸ§  **Start with a Simple Question**

I always ask students:

> **â€œProgram.cs file itka important ka aahe?â€**
> Why is Program.cs *so important*?

And usually someone answers:

* It has `Main()`
* It is the entry point

âœ… Correctâ€¦ but **thatâ€™s only 10% of the story**.

## ğŸ§© **Program.cs â€“ What It Really Does**

Think of **Program.cs** as:

> ğŸ–¥ï¸ **The motherboard of your application**

What does a motherboard do?

* It decides **which processor fits**
* Which **RAM** can be plugged in
* Which **ports** are enabled
* Which components can talk to each other

ğŸ‘‰ **Program.cs does the same thing for software**

### ğŸ”‘ Responsibilities of Program.cs

1ï¸âƒ£ Entry point (`Main`)
2ï¸âƒ£ Startup pipeline
3ï¸âƒ£ Middleware configuration
4ï¸âƒ£ **Dependency Injection configuration**
5ï¸âƒ£ Application wiring

Especially in **MVC architecture**, Program.cs is **not optional thinking**â€”it is **architectural thinking**.


## ğŸ”Œ Dependency Injection â€“ Configuration, Not Coding

I tell students:

> *â€œTumcha controller kasa banaycha te tumhi code madhe lihitaâ€¦
> pan konta service kontya interface sobat use honar, te tumhi Program.cs madhe decide karta.â€*

That is **configuration**, not implementation.

Example:

```csharp
builder.Services.AddScoped<IShoppingCartService, ShoppingCartService>();
```

This line says:

> â€œHey application,
> if tomorrow a controller asks for `IShoppingCartService`,
> **this is the concrete class you must provide**.â€

## ğŸ§  Interface First Thinking

This is very important.

* Controller should **never depend on a concrete class**
* Controller should depend only on **interface**

Why?

Because:

* Implementation may change
* Interface should not

This is **loose coupling + future readiness**.

## ğŸ§© Is This Configuration or Setting?

Students ask:

> â€œSir, configuration mhantje kay? Settings ka?â€

Answer:

ğŸ‘‰ **Yesâ€”but configuration is more powerful than settings**

* `appsettings.json` â†’ values
* `Program.cs` â†’ **behavior**

Program.cs decides:

* Which service lives how long
* Which controller gets which dependency
* How the application behaves internally

## ğŸ¤– AI Tools Are Here â€“ But Responsibility Is Yours

Today we have:

* ChatGPT
* GitHub Copilot
* Gemini
* Perplexity

They can:

* Generate skeletons
* Write repetitive code
* Speed up development

But remember:

> âš ï¸ **AI writes code, YOU approve architecture**

Companies today want:

* Faster development
* **But with standards**
* **Senior developers accountable for code**

Thatâ€™s why:

* Design patterns
* IOC
* SOLID principles
  are **more important than ever**

## ğŸ›’ Real Feature Thinking â€“ Shopping Cart

Letâ€™s come to a real requirement:

> â€œI am writing an ASP.NET Core MVC application
> with a ProductsController.
> I want to add a ShoppingCart feature.â€

Good.

Now stop coding.

### âŒ Donâ€™t start with controller code

### âœ… Start with **feature thinking**

## ğŸ§  Feature â†’ Design â†’ Code (Correct Flow)

### Step 1: Define the feature

* Add item to cart
* Remove item from cart
* View cart

### Step 2: Identify business objects

* Product
* CartItem
* ShoppingCart

### Step 3: Define service

* `IShoppingCartService`

### Step 4: Implement service

* `ShoppingCartService`

### Step 5: Register service

ğŸ‘‰ **Program.cs**

### Step 6: Inject service

ğŸ‘‰ Constructor of `ShoppingCartController`

## ğŸ§© Where Does Repository & DB Come?

* Product catalog â†’ Database
* Cart â†’ Session / Memory
* Repository layer â†’ Data abstraction

You **donâ€™t mix** these responsibilities.

Thatâ€™s called:

> **Separation of Concerns**

## ğŸ—ï¸ Skeleton First, Feature Later

Good developers:

* Create skeleton
* Plug features gradually

Shopping cart today
Order processing tomorrow
Payment next
Delivery tracking later

This is **scalable architecture**.

## ğŸ§  Ordinary Code vs Professional Code

I always say:

> â€œGreat companies donâ€™t want extraordinary code.
> They want **ordinary code written the right way**.â€

Readable
Maintainable
Testable
Extendable

## ğŸ“ Object Oriented Methodology (OOM)

What we are actually doing is:

* Modeling real-world problems
* Converting them into objects
* Defining responsibilities

This is:

> **Object Oriented Modeling**

And implementing it using:

* MVC
* DI
* Interfaces
* SOLID

## ğŸ”„ Agile Enters the Picture

Now industry process comes in.

### Agile says:

* Donâ€™t build everything at once
* Build feature by feature

## ğŸ“ User Story Example

> **As a user**,
> I want to add items to my shopping cart
> so that I can purchase them later.

### Acceptance Criteria

* User can add item to cart
* User can remove item from cart
* User can view cart

Simple. Clear. Testable.

## ğŸ§ª Test Driven Thinking

Before coding:

* Test cases are written

Example test case:

* Click â€œAdd to Cartâ€
* Expected result: item appears in cart

These test cases go to:

* Manual tester
* Automation tester

Application becomes:

> **AUT â€“ Application Under Test**


## ğŸš¦ Sprint Flow

1ï¸âƒ£ User story defined
2ï¸âƒ£ Acceptance criteria written
3ï¸âƒ£ Test cases prepared
4ï¸âƒ£ Developer codes
5ï¸âƒ£ Tests executed
6ï¸âƒ£ If pass â†’ demo
7ï¸âƒ£ If fail â†’ no demo

That is **Agile Sprint**.


## ğŸ§  Final Mentor Wisdom

> Program.cs is not a file.
> It is a **decision-making hub**.

> Features are not code.
> They are **problems to be modeled**.

> AI is not a replacement.
> It is an **accelerator with responsibility**.

