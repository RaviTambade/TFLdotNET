
## ğŸ§ª Hands-On Lab :Building a **Secure REST API with .NET 9**

> **Lab Goal:**
> Build a **secure, production-ready API** using .NET 9 practices â€”
> authentication, authorization, validation, encryption, logging, and testing.

## ğŸ§  What You Will Learn

By the end of this lab, you will:

* Build a secure ASP.NET Core API (.NET 9)
* Implement JWT authentication
* Apply role-based authorization
* Validate inputs safely
* Secure secrets & configuration
* Add logging & security headers
* Understand **why** each security step exists

## ğŸ›  Prerequisites

* .NET SDK 9 installed
* VS Code or Visual Studio
* Postman / curl
* Basic C# & HTTP knowledge

## ğŸ§© Lab Scenario

You are building a **Product Management API** for an internal system.

### Requirements

* Only authenticated users can access APIs
* Only **Admin** can add products
* Inputs must be validated
* Secrets must not be hardcoded
* All access must be logged

# ğŸ”¹ Step 1: Create .NET 9 Web API Project

```bash
dotnet new webapi -n SecureProductApi
cd SecureProductApi
```

Run the project:

```bash
dotnet run
```

Verify:

* HTTPS is enabled
* Swagger UI opens securely

âœ… **Checkpoint:** API runs on HTTPS


# ğŸ”¹ Step 2: Understand the Security Pipeline

```
Request
  |
HTTPS
  |
Authentication
  |
Authorization
  |
Validation
  |
Business Logic
  |
Logging
  |
Response
```

ğŸ“Œ Security is **pipeline-based**, not controller-based.

# ğŸ”¹ Step 3: Add JWT Authentication

### Install Packages

```bash
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
```

### Configure JWT (Program.cs)

```csharp
builder.Services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", options =>
    {
        options.TokenValidationParameters = new()
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = "SecureApi",
            ValidAudience = "SecureApiUsers",
            IssuerSigningKey =
                new SymmetricSecurityKey(
                    Encoding.UTF8.GetBytes(builder.Configuration["JwtKey"]))
        };
    });
```

```csharp
app.UseAuthentication();
app.UseAuthorization();
```

ğŸ“Œ **Never hardcode JwtKey**

# ğŸ”¹ Step 4: Secure Secrets (User Secrets)

```bash
dotnet user-secrets init
dotnet user-secrets set "JwtKey" "SUPER_SECRET_KEY_123"
```

ğŸ“Œ Secrets stay **outside source code**


# ğŸ”¹ Step 5: Create Secure DTO & Validation

### Product DTO

```csharp
public record CreateProductDto(
    string Name,
    decimal Price
);
```

### Validation with DataAnnotations

```csharp
public class CreateProductDto
{
    [Required]
    [StringLength(100)]
    public string Name { get; set; }

    [Range(1, 100000)]
    public decimal Price { get; set; }
}
```

ğŸ“Œ Validation happens **before business logic**

# ğŸ”¹ Step 6: Secure Controller with Authorization

```csharp
[ApiController]
[Route("api/products")]
public class ProductsController : ControllerBase
{
    [HttpGet]
    [Authorize]
    public IActionResult Get()
    {
        return Ok("Secure product list");
    }

    [HttpPost]
    [Authorize(Roles = "Admin")]
    public IActionResult Create(CreateProductDto dto)
    {
        return Ok("Product created");
    }
}
```

- ğŸ“Œ UI hiding â‰  API security
- ğŸ“Œ Roles enforced **server-side**


# ğŸ”¹ Step 7: Generate JWT Token (Demo Auth Controller)

```csharp
[HttpPost("login")]
public IActionResult Login()
{
    var claims = new[]
    {
        new Claim(ClaimTypes.Name, "student"),
        new Claim(ClaimTypes.Role, "Admin")
    };

    var key = new SymmetricSecurityKey(
        Encoding.UTF8.GetBytes(_config["JwtKey"]));

    var token = new JwtSecurityToken(
        issuer: "SecureApi",
        audience: "SecureApiUsers",
        claims: claims,
        expires: DateTime.UtcNow.AddMinutes(30),
        signingCredentials: new SigningCredentials(key, SecurityAlgorithms.HmacSha256)
    );

    return Ok(new
    {
        token = new JwtSecurityTokenHandler().WriteToken(token)
    });
}
```

# ğŸ”¹ Step 8: Test Security with Postman

### Test Cases

| Scenario       | Expected Result  |
| -------------- | ---------------- |
| No token       | 401 Unauthorized |
| Token, no role | 403 Forbidden    |
| Admin token    | 200 OK           |

ğŸ“Œ **Security success = request blocked correctly**


# ğŸ”¹ Step 9: Add Security Headers Middleware

```csharp
app.Use(async (context, next) =>
{
    context.Response.Headers["X-Frame-Options"] = "DENY";
    context.Response.Headers["X-Content-Type-Options"] = "nosniff";
    context.Response.Headers["Referrer-Policy"] = "no-referrer";
    await next();
});
```

ğŸ“Œ Small headers, big protection

# ğŸ”¹ Step ğŸ”Ÿ Add Structured Logging (Serilog)

```bash
dotnet add package Serilog.AspNetCore
```

```csharp
Log.Information("User {User} accessed {Path}",
    User.Identity?.Name,
    HttpContext.Request.Path);
```

ğŸ“Œ Log **actions**, not secrets


# ğŸ”¹ Step 1ï¸âƒ£1ï¸âƒ£ Secure Error Handling

```csharp
app.UseExceptionHandler("/error");
```

```csharp
app.Map("/error", (HttpContext ctx) =>
{
    return Results.Problem("Something went wrong");
});
```

ğŸ“Œ Never expose stack traces in production


# ğŸ”¹ Step 1ï¸âƒ£2ï¸âƒ£ Security Testing (Student Exercise)

### Try Attacks

* Access API without token
* Modify token
* Send invalid input
* Call admin API as user

âœ… API must **block all invalid attempts**


## ğŸ§  Final Checklist (Student Self-Check)

âœ” HTTPS enabled
âœ” JWT authentication applied
âœ” Authorization enforced
âœ” Inputs validated
âœ” Secrets externalized
âœ” Logs added
âœ” Headers configured

## ğŸ“ Mentor Reflection

> â€œA secure API is not one that never gets attacked â€”
> itâ€™s one that **never trusts blindly**.â€

If students complete this lab honestly, they:

* Understand **real security**
* Gain **industry confidence**
* Stop fearing architecture & auth

## ğŸš€ Optional Extensions

* Add EF Core with parameterized queries
* Integrate Azure AD / Entra ID
* Add rate limiting
* Add OWASP ZAP scan



# Why Security Was Never â€œOptionalâ€ for Me

*A mentorâ€™s story from the trenches*

I still remember the year **2008** very clearly.

We were proud of what we had builtâ€”an ERP module for a logistics company.
It was fast. Feature-rich. Clients loved the dashboards. Management loved the demos.

Then one morning, the phone rang.

Not a feature request.
Not a bug report.

A **security incident**.

Hereâ€™s the uncomfortable truth:
The attacker didnâ€™t hack our server.
Didnâ€™t break encryption.
Didnâ€™t exploit infrastructure.

They simply **manipulated a hidden form field**.

We had trusted input.
We had assumed users would behave.
We had treated security as something to â€œadd later.â€

That incident permanently changed how I thinkâ€”and how I mentor.

> **Security is not a checklist.
> Itâ€™s a habit.
> Itâ€™s a mindset you carry into every line of code.**

## Authentication & Authorization â€” *â€œKnow Whoâ€™s Knockingâ€*

A few years later, another lesson arrivedâ€”this time quietly.

We deployed an application where the **admin menu was hidden** in the UI.
The team felt safe.

Then a curious user guessed the URL.

And it worked.

That day I learned something I still repeat to students:

> **If an endpoint exists, someone will find it.**

From that moment onward:

* UI stopped being a security boundary
* Server-side protection became non-negotiable

Today, I insist on:

* ASP.NET Core Identity
* OAuth / OpenID Connect
* Role-based and claims-based authorization

Because hiding a door doesnâ€™t mean itâ€™s locked.


## Secure Communication â€” *â€œHTTPS Is Not Optionalâ€*

I once heard a developer say:

> â€œItâ€™s just a test environment. No need for HTTPS.â€

A packet sniffer disagreed.

That incident taught me a brutal truth:
Attackers donâ€™t care whether your app is **dev, test, or prod**.

Now my rule is simple:
If data is moving, it must be encrypted.

HTTPS everywhere.
TLS always.
HSTS enabled.

Because encryption is not about trustâ€”itâ€™s about **respecting the data youâ€™re handling**.

## Data Encryption â€” *â€œIf Itâ€™s Confidential, Encrypt Itâ€*

One client proudly told us:
â€œWe store passwords in the database so admins can help users.â€

A few weeks later, a disgruntled intern demonstrated why that was a terrible idea.

That was the last time I ever allowed:

* Plain text passwords
* Hardcoded secrets
* Shared credentials

Since then:

* Passwords are hashed, never stored
* Secrets live outside code
* Key Vaults replace config files

My personal rule:

> **If you wouldnâ€™t want it printed on a newspaper tomorrow, encrypt it today.**

## Input Validation â€” *â€œNever Trust User Inputâ€*

This one came from an intern.

He typed:

```
'; DROP TABLE Users;--
```

And it worked.

No hacker sophistication.
No advanced exploit.
Just blind trust.

That single moment reshaped my teaching style.

Now I tell students:
Every input field is a doorway.
Some lead inside.
Some lead straight to disaster.

So we validate:

* At DTO level
* At business rules level
* At database boundaries

Trust is never assumed.
It is always **verified**.

## Secure Coding Practices â€” *â€œEgo Is a Security Riskâ€*

I once reviewed code where a developer had written **custom cryptography**.

When I asked why, the answer was:
â€œWhy use libraries when I can build my own?â€

That code never went to production.

Security taught me humility.
The smartest engineers donâ€™t reinvent encryptionâ€”they **reuse proven systems**.

Today, I push teams to:

* Follow OWASP Top 10
* Trust the framework
* Review code with a security lens

Because security is not about brilliance.
Itâ€™s about **discipline**.

## Security Headers â€” *â€œMiss One, Pay the Priceâ€*

We once suffered a clickjacking attack.

The root cause?
A missing header.

One line of configuration.
One forgotten safeguard.

Thatâ€™s when I realized:
Security isnâ€™t always about complex systems.
Sometimes itâ€™s about **remembering the basics**.

Now, headers are part of architecture, not an afterthought.
Theyâ€™re the helmet and armor of your application.

## Logging & Auditing â€” *â€œIf Itâ€™s Not Logged, It Never Happenedâ€*

Iâ€™ve seen outages caused by failed login attempts.

The worst part?
No one knew why.

No logs.
No audit trail.
Just confusion.

Thatâ€™s when logging stopped being â€œdebugging helpâ€ for me.
It became a **security tool**.

Today:

* Auth failures are logged
* Access decisions are traceable
* Sensitive data is never written

Because silence during failure is more dangerous than failure itself.

## Compliance â€” *â€œThe Law Doesnâ€™t Ask Permissionâ€*

A startup once told me:
â€œGDPR doesnâ€™t apply to usâ€”weâ€™re not in Europe.â€

One of their users was.

Compliance taught me something important:
Geography doesnâ€™t protect you.
Ignorance doesnâ€™t excuse you.

Now I design systems assuming:

* Someone will request their data
* Someone will request deletion
* Someone will audit the trail

Security without compliance is unfinished work.

## Patch Management â€” *â€œOne Unpatched DLL Can Sink the Shipâ€*

Iâ€™ve personally seen breaches caused by:

* A single outdated NuGet package
* A known vulnerability
* A postponed update

Now I treat dependency updates like health checks.
Uncomfortable sometimesâ€”but necessary.

Because old code doesnâ€™t fail loudly.
It fails silently.

## Security Testing â€” *â€œAssume Youâ€™re Already Vulnerableâ€*

The most humbling moment?

Running a scan and discovering:
Three public endpoints.
No authentication.

That scan taught me this:
Security testing isnâ€™t paranoia.
Itâ€™s honesty.

Now we scan early.
We scan often.
We assume something is wrongâ€”and go looking.

## Final Mentor Reflection

After all these years, one belief has stayed constant:

> **You donâ€™t need to be a security expert.
> But you must be security-aware.**

Security is not fear.
It is **trust engineering**.

Compliance is not paperwork.
It is **user respect**.

And as a .NET developer or architect,
you are not just writing codeâ€”

You are deciding **how safe someone elseâ€™s data will be**.

ğŸ” Secure code is clean code.
ğŸ“‹ Compliant systems are trusted systems.

Thatâ€™s the lesson I pass on.