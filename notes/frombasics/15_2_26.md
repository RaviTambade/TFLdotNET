# Create GreenhouseApi Step by Step Using .NET CLI

This guide recreates the **Greenhouse IoT Web API** from scratch using .NET CLI commands and the required source files. Target: **.NET 8**.
 

## Prerequisites

- **.NET 8 SDK** installed. Check with:
  ```powershell
  dotnet --version
  ```
  You should see `8.0.x`.

---

## Step 1: Create a new Web API project

From the folder where you want the solution (e.g. `d:\tryout`), run:

```powershell
dotnet new webapi -n GreenhouseApi -o GreenhouseApi
```

- `-n GreenhouseApi` — project name  
- `-o GreenhouseApi` — output folder  

This creates a minimal ASP.NET Core Web API with controllers and default files.

---

## Step 2: Optional — create a solution and add the project

If you want a solution file:

```powershell
dotnet new sln -n GreenhouseApi -o .
dotnet sln add GreenhouseApi/GreenhouseApi.csproj
```

If you created the project inside an existing folder (e.g. `timepass`), run the above from that folder so the paths match.
 

## Step 3: Add Swagger/OpenAPI package

Ensure Swagger is available (the template may already include it):

```powershell
cd GreenhouseApi
dotnet add package Swashbuckle.AspNetCore
```

---

## Step 4: Adjust the project file (optional)

Edit `GreenhouseApi.csproj` so it matches the existing project. Replace its contents with:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <RootNamespace>GreenhouseApi</RootNamespace>
    <AssemblyName>GreenhouseApi</AssemblyName>
  </PropertyGroup>

</Project>
```

---

## Step 5: Create folder structure

From the `GreenhouseApi` project folder, create the namespaces as folders:

**PowerShell:**

```powershell
mkdir Models
mkdir Services
mkdir Repositories
mkdir Controllers
```

**CMD:**

```cmd
mkdir Models
mkdir Services
mkdir Repositories
mkdir Controllers
```

*(If the template already created `Controllers`, skip that line.)*

---

## Step 6: Remove the template controller (optional)

The template adds `Controllers/WeatherForecastController.cs` and possibly `WeatherForecast.cs`. Delete them so only our API remains:

```powershell
Remove-Item Controllers/WeatherForecastController.cs -ErrorAction SilentlyContinue
Remove-Item WeatherForecast.cs -ErrorAction SilentlyContinue
```

---

## Step 7: Create the model classes

### 7.1 `Models/SensorReading.cs`

```csharp
namespace GreenhouseApi.Models;

/// <summary>
/// Represents a single sensor reading from a greenhouse.
/// </summary>
public class SensorReading
{
    public int Id { get; set; }
    public string GreenhouseId { get; set; } = string.Empty;
    public string SensorType { get; set; } = string.Empty; // e.g. Temperature, Humidity, Light, SoilMoisture
    public double Value { get; set; }
    public string Unit { get; set; } = string.Empty; // e.g. °C, %, lux, %
    public DateTime Timestamp { get; set; }
}
```

### 7.2 `Models/GreenhouseData.cs`

```csharp
namespace GreenhouseApi.Models;

/// <summary>
/// Root model for JSON file - holds all sensor readings.
/// </summary>
public class GreenhouseData
{
    public List<SensorReading> SensorReadings { get; set; } = new();
}
```

---

## Step 8: Create repository layer

### 8.1 `Repositories/GreenhouseOptions.cs`

```csharp
namespace GreenhouseApi.Repositories;

public class GreenhouseOptions
{
    public const string SectionName = "Greenhouse";
    public string JsonFilePath { get; set; } = "greenhouse.json";
}
```

### 8.2 `Repositories/IGreenhouseRepository.cs`

```csharp
using GreenhouseApi.Models;

namespace GreenhouseApi.Repositories;

public interface IGreenhouseRepository
{
    Task<IReadOnlyList<SensorReading>> GetAllAsync(CancellationToken cancellationToken = default);
    Task<SensorReading?> GetByIdAsync(int id, CancellationToken cancellationToken = default);
    Task<SensorReading> AddAsync(SensorReading reading, CancellationToken cancellationToken = default);
    Task<SensorReading?> UpdateAsync(int id, SensorReading reading, CancellationToken cancellationToken = default);
    Task<bool> DeleteAsync(int id, CancellationToken cancellationToken = default);
}
```

### 8.3 `Repositories/GreenhouseRepository.cs`

```csharp
using System.Text.Json;
using GreenhouseApi.Models;
using Microsoft.Extensions.Options;

namespace GreenhouseApi.Repositories;

public class GreenhouseRepository : IGreenhouseRepository
{
    private readonly string _jsonFilePath;
    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        WriteIndented = true
    };

    public GreenhouseRepository(IOptions<GreenhouseOptions> options)
    {
        _jsonFilePath = options.Value.JsonFilePath ?? "greenhouse.json";
    }

    private async Task<GreenhouseData> LoadDataAsync(CancellationToken cancellationToken)
    {
        if (!File.Exists(_jsonFilePath))
            return new GreenhouseData();

        await using var stream = File.OpenRead(_jsonFilePath);
        var data = await JsonSerializer.DeserializeAsync<GreenhouseData>(stream, JsonOptions, cancellationToken);
        return data ?? new GreenhouseData();
    }

    private async Task SaveDataAsync(GreenhouseData data, CancellationToken cancellationToken)
    {
        await using var stream = File.Create(_jsonFilePath);
        await JsonSerializer.SerializeAsync(stream, data, JsonOptions, cancellationToken);
    }

    public async Task<IReadOnlyList<SensorReading>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        var data = await LoadDataAsync(cancellationToken);
        return data.SensorReadings;
    }

    public async Task<SensorReading?> GetByIdAsync(int id, CancellationToken cancellationToken = default)
    {
        var data = await LoadDataAsync(cancellationToken);
        return data.SensorReadings.FirstOrDefault(r => r.Id == id);
    }

    public async Task<SensorReading> AddAsync(SensorReading reading, CancellationToken cancellationToken = default)
    {
        var data = await LoadDataAsync(cancellationToken);
        var nextId = data.SensorReadings.Count > 0
            ? data.SensorReadings.Max(r => r.Id) + 1
            : 1;
        reading.Id = nextId;
        if (reading.Timestamp == default)
            reading.Timestamp = DateTime.UtcNow;
        data.SensorReadings.Add(reading);
        await SaveDataAsync(data, cancellationToken);
        return reading;
    }

    public async Task<SensorReading?> UpdateAsync(int id, SensorReading reading, CancellationToken cancellationToken = default)
    {
        var data = await LoadDataAsync(cancellationToken);
        var index = data.SensorReadings.FindIndex(r => r.Id == id);
        if (index < 0) return null;
        reading.Id = id;
        data.SensorReadings[index] = reading;
        await SaveDataAsync(data, cancellationToken);
        return reading;
    }

    public async Task<bool> DeleteAsync(int id, CancellationToken cancellationToken = default)
    {
        var data = await LoadDataAsync(cancellationToken);
        var removed = data.SensorReadings.RemoveAll(r => r.Id == id);
        if (removed == 0) return false;
        await SaveDataAsync(data, cancellationToken);
        return true;
    }
}
```

---

## Step 9: Create service layer

### 9.1 `Services/IGreenhouseService.cs`

```csharp
using GreenhouseApi.Models;

namespace GreenhouseApi.Services;

public interface IGreenhouseService
{
    Task<IReadOnlyList<SensorReading>> GetAllReadingsAsync(CancellationToken cancellationToken = default);
    Task<SensorReading?> GetReadingByIdAsync(int id, CancellationToken cancellationToken = default);
    Task<SensorReading> CreateReadingAsync(SensorReading reading, CancellationToken cancellationToken = default);
    Task<SensorReading?> UpdateReadingAsync(int id, SensorReading reading, CancellationToken cancellationToken = default);
    Task<bool> DeleteReadingAsync(int id, CancellationToken cancellationToken = default);
}
```

### 9.2 `Services/GreenhouseService.cs`

```csharp
using GreenhouseApi.Models;
using GreenhouseApi.Repositories;

namespace GreenhouseApi.Services;

public class GreenhouseService : IGreenhouseService
{
    private readonly IGreenhouseRepository _repository;

    public GreenhouseService(IGreenhouseRepository repository)
    {
        _repository = repository;
    }

    public Task<IReadOnlyList<SensorReading>> GetAllReadingsAsync(CancellationToken cancellationToken = default)
        => _repository.GetAllAsync(cancellationToken);

    public Task<SensorReading?> GetReadingByIdAsync(int id, CancellationToken cancellationToken = default)
        => _repository.GetByIdAsync(id, cancellationToken);

    public Task<SensorReading> CreateReadingAsync(SensorReading reading, CancellationToken cancellationToken = default)
        => _repository.AddAsync(reading, cancellationToken);

    public Task<SensorReading?> UpdateReadingAsync(int id, SensorReading reading, CancellationToken cancellationToken = default)
        => _repository.UpdateAsync(id, reading, cancellationToken);

    public Task<bool> DeleteReadingAsync(int id, CancellationToken cancellationToken = default)
        => _repository.DeleteAsync(id, cancellationToken);
}
```

---

## Step 10: Create the API controller

### 10.1 `Controllers/GreenhouseController.cs`

```csharp
using GreenhouseApi.Models;
using GreenhouseApi.Services;
using Microsoft.AspNetCore.Mvc;

namespace GreenhouseApi.Controllers;

[ApiController]
[Route("api/[controller]")]
[Produces("application/json")]
public class GreenhouseController : ControllerBase
{
    private readonly IGreenhouseService _greenhouseService;

    public GreenhouseController(IGreenhouseService greenhouseService)
    {
        _greenhouseService = greenhouseService;
    }

    /// <summary>Get all sensor readings.</summary>
    [HttpGet]
    [ProducesResponseType(typeof(IReadOnlyList<SensorReading>), StatusCodes.Status200OK)]
    public async Task<ActionResult<IReadOnlyList<SensorReading>>> GetAll(CancellationToken cancellationToken)
    {
        var readings = await _greenhouseService.GetAllReadingsAsync(cancellationToken);
        return Ok(readings);
    }

    /// <summary>Get a sensor reading by id.</summary>
    [HttpGet("{id:int}")]
    [ProducesResponseType(typeof(SensorReading), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<ActionResult<SensorReading>> GetById(int id, CancellationToken cancellationToken)
    {
        var reading = await _greenhouseService.GetReadingByIdAsync(id, cancellationToken);
        if (reading is null)
            return NotFound();
        return Ok(reading);
    }

    /// <summary>Create a new sensor reading.</summary>
    [HttpPost]
    [ProducesResponseType(typeof(SensorReading), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<ActionResult<SensorReading>> Create([FromBody] SensorReading reading, CancellationToken cancellationToken)
    {
        var created = await _greenhouseService.CreateReadingAsync(reading, cancellationToken);
        return CreatedAtAction(nameof(GetById), new { id = created.Id }, created);
    }

    /// <summary>Update an existing sensor reading.</summary>
    [HttpPut("{id:int}")]
    [ProducesResponseType(typeof(SensorReading), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<ActionResult<SensorReading>> Update(int id, [FromBody] SensorReading reading, CancellationToken cancellationToken)
    {
        var updated = await _greenhouseService.UpdateReadingAsync(id, reading, cancellationToken);
        if (updated is null)
            return NotFound();
        return Ok(updated);
    }

    /// <summary>Delete a sensor reading.</summary>
    [HttpDelete("{id:int}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> Delete(int id, CancellationToken cancellationToken)
    {
        var deleted = await _greenhouseService.DeleteReadingAsync(id, cancellationToken);
        if (!deleted)
            return NotFound();
        return NoContent();
    }
}
```

---

## Step 11: Replace Program.cs

Replace the contents of `Program.cs` with:

```csharp
using GreenhouseApi.Repositories;
using GreenhouseApi.Services;
using Microsoft.Extensions.Options;

var builder = WebApplication.CreateBuilder(args);

// Configure options
builder.Services.Configure<GreenhouseOptions>(
    builder.Configuration.GetSection(GreenhouseOptions.SectionName));

// Repository & Service
builder.Services.AddScoped<IGreenhouseRepository, GreenhouseRepository>();
builder.Services.AddScoped<IGreenhouseService, GreenhouseService>();

builder.Services.AddControllers()
    .AddJsonOptions(options =>
    {
        options.JsonSerializerOptions.PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase;
    });

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new() { Title = "Greenhouse IoT API", Version = "v1" });
});

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();
```

---

## Step 12: Configure appsettings

### 12.1 `appsettings.json`

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "Greenhouse": {
    "JsonFilePath": "greenhouse.json"
  }
}
```

### 12.2 `appsettings.Development.json`

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Information"
    }
  }
}
```

---

## Step 13: Set launch profile (optional)

Ensure `Properties/launchSettings.json` has a profile that opens Swagger. Example:

```json
{
  "profiles": {
    "GreenhouseApi": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:5001;http://localhost:5000",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
```

---

## Step 14: Build and run with .NET CLI

From the **GreenhouseApi** project directory:

**Restore and build:**

```powershell
dotnet restore
dotnet build
```

**Run:**

```powershell
dotnet run
```

**Run with hot reload (optional):**

```powershell
dotnet watch run
```

---

## Step 15: Verify the API

1. Open a browser and go to: **https://localhost:5001/swagger** or **http://localhost:5000/swagger**  
2. You should see the **Greenhouse IoT API** Swagger UI.  
3. Try **GET /api/greenhouse** — it should return an empty array `[]` (or existing data if `greenhouse.json` is present).

---

## Optional: Seed data file

Create `greenhouse.json` in the project folder to preload sensor readings (camelCase for JSON):

```json
{
  "sensorReadings": [
    {
      "id": 1,
      "greenhouseId": "GH-001",
      "sensorType": "Temperature",
      "value": 24.5,
      "unit": "°C",
      "timestamp": "2025-02-14T10:00:00Z"
    },
    {
      "id": 2,
      "greenhouseId": "GH-001",
      "sensorType": "Humidity",
      "value": 65,
      "unit": "%",
      "timestamp": "2025-02-14T10:00:00Z"
    }
  ]
}
```

---

## .NET CLI commands summary

| Step | Command |
|------|--------|
| Create Web API | `dotnet new webapi -n GreenhouseApi -o GreenhouseApi` |
| Create solution | `dotnet new sln -n GreenhouseApi -o .` |
| Add project to solution | `dotnet sln add GreenhouseApi/GreenhouseApi.csproj` |
| Add Swagger package | `cd GreenhouseApi` then `dotnet add package Swashbuckle.AspNetCore` |
| Restore | `dotnet restore` |
| Build | `dotnet build` |
| Run | `dotnet run` |
| Run with watch | `dotnet watch run` |
| Publish | `dotnet publish -c Release -o ./publish` |

---

## Project layout (after creation)

```
GreenhouseApi/
├── Controllers/
│   └── GreenhouseController.cs
├── Models/
│   ├── SensorReading.cs
│   └── GreenhouseData.cs
├── Repositories/
│   ├── GreenhouseOptions.cs
│   ├── IGreenhouseRepository.cs
│   └── GreenhouseRepository.cs
├── Services/
│   ├── IGreenhouseService.cs
│   └── GreenhouseService.cs
├── Properties/
│   └── launchSettings.json
├── Program.cs
├── appsettings.json
├── appsettings.Development.json
├── greenhouse.json          (optional)
└── GreenhouseApi.csproj
```

You have now created the GreenhouseApi step by step using the .NET CLI and the listed source files.
